The algorithm you've described is a variation of Euclidean division or Euclid's algorithm, which is used to find the greatest common divisor (GCD) of two numbers. In your case, you're interested in finding the denominator when the division has a remainder of 0, which would be the GCD.

Here's a Python implementation of the algorithm to find the GCD (denominator) recursively:

```python
def gcd(a, b):
    if b == 0:
        return a
    else:
        return gcd(b, a % b)

# Example usage:
a = 48
b = 18
x = max(a, b)
y = min(a, b)
denominator = gcd(x, y)
print("Denominator (GCD):", denominator)
```

In this code, the `gcd` function follows the Euclidean algorithm by repeatedly dividing the larger number by the smaller non-zero remainder until the remainder is 0. The last non-zero remainder is the GCD, which is the denominator you're looking for.

As for your question, the specific process you've described with the conditions for "r", "s", "d", "e", and "f" is not a standard variation of Euclid's algorithm, but it ultimately leads to finding the GCD using the same principles. The standard algorithm is more straightforward and efficient, as shown in the code above.