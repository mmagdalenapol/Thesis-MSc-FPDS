The algorithm you're describing is called the Sieve of Eratosthenes, an ancient algorithm for finding all prime numbers up to a given limit. Here's a Python implementation of the algorithm using recursion:

```python
import math

def sieve_of_eratosthenes(x, primes=None, current=2):
    if primes is None:
        primes = list(range(2, x))
    if current > math.isqrt(x):
        return primes

    for multiple in range(current * current, x, current):
        if multiple in primes:
            primes.remove(multiple)

    next_prime = primes[primes.index(current) + 1]
    return sieve_of_eratosthenes(x, primes, next_prime)

x = 50
result = sieve_of_eratosthenes(x)
print("Prime numbers up to", x, "are:", result)
```

This code initializes a list of numbers from 2 to `x` and starts with the first prime number, 2. It removes all multiples of 2 from the list, then moves to the next number in the list and repeats the process. The recursion stops when the current number exceeds the square root of `x`.

The output for `x = 50` will be:

```
Prime numbers up to 50 are: [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]
```

The Sieve of Eratosthenes is an efficient algorithm for finding primes, with a time complexity of O(n log log n) and a space complexity of O(n).