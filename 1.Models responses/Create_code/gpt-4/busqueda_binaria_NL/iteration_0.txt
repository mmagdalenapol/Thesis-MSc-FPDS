To achieve the implementation of the algorithm you have described, we will make use of a classic binary search approach on a sorted list. Binary search works by repeatedly dividing the list into halves until the target element is found or the sublist cannot be divided further.

Here's a Python implementation of the described task:

```python
def binary_search(x, a):
    low = 0
    high = len(x) - 1

    while low <= high:
        mid = (low + high) // 2

        if x[mid] == a:
            return mid
        elif x[mid] < a:
            low = mid + 1
        else:
            high = mid - 1

    # If the length is exactly 2 and the target was not found in the loop:
    if low < high and high - low == 1:
        if x[low] == a:
            return low
        elif x[high] == a:
            return high
    
    return -1  # a is not in the list

# Example usage
x = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
a = 7
print(binary_search(x, a))  # should return the index of 7 in the list, which is 6

a = 11
print(binary_search(x, a))  # since 11 is not in the list, this should return -1
```

### Explanation:
1. **Initialization**: We start by setting `low` and `high` pointers to indicate the range of numbers in the list to consider. Initially, `low` is at the start of the list and `high` is at its end.

2. **Binary Search Loop**: The loop continues as long as `low` is less than or equal to `high`. Inside the loop, we calculate the middle index (`mid`). Depending on the value at `x[mid]`, we adjust the `low` and `high`:
   - If `x[mid]` equals `a`, we found the target and return `mid`.
   - If `x[mid]` is less than `a`, it means the target must be in the right half of the list, so we update `low` to `mid + 1`.
   - If `x[mid]` is more than `a`, the target must be in the left half, so we move `high` to `mid - 1`.

3. **Post-Loop Check**: After exiting the loop, if the conditions of the list being size 2 and element not found were met, it checks both elements.

4. **Return -1**: If none of the above conditions confirm the existence of `a` in `x`, we return -1 to indicate that `a` was not found in `x`.

This implementation ensures efficient searching with a worst-case time complexity of `O(log n)`, where `n` is the number of elements in `x`. The edge case handling with lists of length exactly 2 after narrowing down through binary search ensures robustness in diverse scenarios.