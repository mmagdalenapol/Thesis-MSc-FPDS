It seems you are describing a modified binary search to find the index of a given element, `a`, in a sorted list, `x`. Standard binary search can be adapted to return the index of the element if it exists or -1 if it does not. Here's a Python function to implement your requirements:

```python
def special_binary_search(x, a):
    low, high = 0, len(x) - 1

    while low <= high:
        mid = (low + high) // 2

        if x[mid] == a:
            return mid
        elif x[mid] < a:
            low = mid + 1
        else:
            high = mid - 1
        
        # Handling the special case when the length becomes 2
        if high - low == 1:
            if x[low] == a:
                return low
            if x[high] == a:
                return high
            return -1
    
    return -1  # Element not found

# Example usage:
sorted_list = [1, 3, 5, 7, 9, 11, 13]
search_element = 7
result = special_binary_search(sorted_list, search_element)
print(f"The index of {search_element} in the list is {result}")
```

### Explanation:

1. **Initialization**:
   - `low` and `high` are initialized to the start and end positions of the list.

2. **Binary Search Loop**:
   - Compute the middle index `mid`.
   - If the middle element `x[mid]` is equal to `a`, return `mid`.
   - Update `low` and `high` based on whether `x[mid]` is less than or greater than `a`.

3. **Special Case When the List has 2 Elements**:
   - If it narrows down to two elements (i.e., `high - low == 1`), check these conditions to see if `x[low]` or `x[high]` is `a` and return the corresponding position. If neither position matches, return -1.

4. **Element Not Found**:
   - If the loop exits without finding `a`, the function returns -1.

The function handles various cases properly, including when the list is reduced to two elements, ensuring that it checks both before concluding that `a` is not present. This is a variant of binary search optimized for a special condition.