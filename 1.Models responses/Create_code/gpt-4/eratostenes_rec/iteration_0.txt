The algorithm described in your message is essentially the "Sieve of Eratosthenes." It's a very efficient method for finding all primes smaller than a given number x.

Here's the Python code that replicates this sieve process recursively as you requested. The code defines a function `recursive_sieve` which carries out the process recursively until the square root of the number x:

```python
def recursive_sieve(n, start=2, sieve=None):
    if sieve is None:
        sieve = list(range(n + 1))  # Initialize the sieve list with all numbers from 0 to n.
        for i in range(2):
            sieve[i] = 0  # Set 0 and 1 to be non-prime explicitly.

    if start * start > n:
        return [num for num in sieve if num]  # Return the numbers that are not set to zero in the sieve.

    if sieve[start] != 0:  # If the current start is a prime number
        for multiple in range(start*start, n + 1, start):
            sieve[multiple] = 0  # Set all multiples of the current prime to zero.

    return recursive_sieve(n, start + 1, sieve)

def primes_up_to(n):
    return recursive_sieve(n)

# Example usage:
x = 30
print("Primes up to", x, ":", primes_up_to(x))
```

### Breakdown:
1. **Initialization**: The function `recursive_sieve` initializes a sieve list with indices representing numbers up to `n`. It sets 0 and 1 as non-prime.
2. **Base Case**: If the square of the current `start` number exceeds `n`, it returns all non-zero values of the sieve list (indicating primes).
3. **Recursion**: If a number is prime (its sieve value is not zero), it removes all multiples of that number from consideration by setting their sieve values to zero.
4. **Recursive Call**: The function calls itself with the next number.

### Complexity & Performance:
- This approach efficiently marks the non-primes and avoids checking multiples of numbers already identified as non-primes.
- The sieve's recursive nature ensures that each layer delves deeper only after handling the current prime, which helps optimize multiple removal.
- The recursive implementation might be less efficient than an iterative approach in languages or setups where recursion depth could lead to issues (like maximum recursion depth exceeded in Python for large `n`). Typically, the iterative version is preferred for extremely large datasets due to stack overflow concerns in recursion.

### Conclusion:
You have successfully replicated the Sieve of Eratosthenes using a recursive approach. For practical purposes, consider iterative versions, especially when dealing with very large numbers due to Python's recursion depth limitations.