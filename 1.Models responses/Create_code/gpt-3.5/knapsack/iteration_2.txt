The problem you are describing is a variation of the Knapsack Problem, specifically the 0/1 Knapsack Problem, where we want to maximize the total value of items included in the knapsack without exceeding the weight capacity.

Here is a Python code that implements the given optimization problem:

```python
def knapsack(p, w, W):
    n = len(p)
    dp = [[0 for _ in range(W+1)] for _ in range(n+1)]

    for i in range(1, n+1):
        for j in range(1, W+1):
            if w[i-1] > j:
                dp[i][j] = dp[i-1][j]
            else:
                dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i-1]] + p[i-1])

    selected_elements = []
    j = W
    for i in range(n, 0, -1):
        if dp[i][j] != dp[i-1][j]:
            selected_elements.append(i-1)
            j -= w[i-1]

    max_sum = dp[n][W]
    return max_sum, selected_elements

# Example usage
p = [60, 100, 120]
w = [10, 20, 30]
W = 50
max_sum, selected_elements = knapsack(p, w, W)
print("Max sum of selected elements:", max_sum)
print("Indexes of selected elements:", selected_elements)
```

In the code above, the function `knapsack` takes the lists of parameters `p` and `w` and the weight limit `W` as inputs, and returns the maximum sum of selected elements and the indexes of the elements that have been used.

I hope this helps! Let me know if you have any further questions.