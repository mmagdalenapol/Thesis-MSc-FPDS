

The algorithm you described is similar to the Sieve of Eratosthenes, a well-known algorithm for finding prime numbers. However, your algorithm is not exactly the same as the Sieve of Eratosthenes, as it uses recursion to remove multiples of each prime number.

Here is a Python implementation of your algorithm:

```
def recursive_sieve(numbers, x):
    if len(numbers) == 0 or numbers[0] > x:
        return []

    next_prime = numbers[0]
    numbers = [n for n in numbers if n % next_prime != 0]
    return [next_prime] + recursive_sieve(numbers, x)

def find_primes(x):
    numbers = list(range(2, x + 1))
    return recursive_sieve(numbers, x)

# Example usage:
x = 100
primes = find_primes(x)
print(primes)
```

This code defines a function `recursive_sieve` that takes a list of numbers and a threshold `x`. It checks if the list is empty or if the first number in the list is greater than `x`. If so, it returns an empty list.

Otherwise, it assumes that the first number in the list is a prime number and stores it in the variable `next_prime`. It then removes all multiples of `next_prime` from the list using a list comprehension. Finally, it returns a list containing `next_prime` and the result of recursively calling `recursive_sieve` on the updated list.

The `find_primes` function takes an input `x` and creates a list of numbers from 2 to `x`. It then calls `recursive_sieve` with this list and `x` as arguments and returns the result.

When you run this code, it will print all prime numbers up to 100.

Note that this algorithm is not the most efficient way to find prime numbers, as it involves a lot of unnecessary calculations. The Sieve of Eratosthenes is a more efficient algorithm for this task.